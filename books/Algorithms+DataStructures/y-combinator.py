from future implement y_combinator

X,Y = y_combinator.split_partitions( for x in map( F1, F2, F3, ... Fn) for y in zip(Q, optimization_matrix) )

combiner_matrix = [ [ Populate(F = Y(X)) ],
                    [ Populate(R = X(Y)) ],
                    [ Populate(Y = F(X)) ],
                    [ Populate(X = R-1(Y) )] ]

M = neural_networks.optimize_combinatorial_logics(combiner_matrix)

program = y_combinator.YY_theory(F(X,R),F(Q,M))
program.compile()
program.run()

"""
The Y-Combinator splits the problem into 2 partitions
"""

P = Problem()
A,B = y_combinator.split_problem(P)
x  = F(B)
x1 = B(A)
x2 = F(A(B))
x3 = F(A(B(X))

"""
With the problem split, we can now choose the optimal partition.
"""
       
optimal_partition = y_combinator.branch(A,B)
Q = optimal_partition( data[lower-boungs:upper-bounds], search-space[slice0:sliceN:sliceZ] )
       
"""
Now assemble the Y-combinator and execute the problem in the subspace selected.
"""
       
R = y_combinator.optimize_function(Q)
y = R(x)       
       
       
       
      
